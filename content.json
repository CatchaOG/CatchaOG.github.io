{"meta":{"title":"隔壁老宋的博客","subtitle":null,"description":null,"author":"宋秀才","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"关于小程序版本自动更新","slug":"关于小程序版本自动更新","date":"2019-07-23T09:18:26.000Z","updated":"2019-07-24T03:11:06.781Z","comments":true,"path":"2019/07/23/关于小程序版本自动更新/","link":"","permalink":"http://yoursite.com/2019/07/23/关于小程序版本自动更新/","excerpt":"","text":"小程序版本更新问题 今天小程序的新版本通过审核了，但是当我打开小程序的时候还是旧版本。需要用户删除旧版小程序再重新搜索打开，这样大大降低了用户体验，为了避免这种情况，我加上了版本检测自动更新机制。 1234567891011121314151617181920212223242526272829303132333435/** * 检测当前的小程序 * 是否是最新版本，是否需要下载、更新 */function checkUpdateVersion() &#123; //创建 UpdateManager 实例 const updateManager = wx.getUpdateManager(); //检测版本更新 updateManager.onCheckForUpdate(function(res) &#123; // 请求完新版本信息的回调 if (res.hasUpdate) &#123; //监听小程序有版本更新事件 updateManager.onUpdateReady(function() &#123; wx.showModal(&#123; title: &apos;更新提示&apos;, content: &apos;新版本已经准备好，是否重启应用？&apos;, success(res) &#123; if (res.confirm) &#123; // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate(); &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function() &#123; // 新版本下载失败 wx.showModal(&#123; title: &apos;已经有新版本咯~&apos;, content: &apos;请您删除当前小程序，到微信 “发现-小程序” 页，重新搜索打开呦~&apos;, &#125;) &#125;) &#125; &#125;)&#125; 根据小程序的运行机制，适合在启动时就进行版本检测的操作","categories":[],"tags":[]},{"title":"关于小程序处理时间格式真机显示NAN的问题","slug":"关于小程序处理时间格式真机显示NAN的问题","date":"2019-07-22T08:38:53.000Z","updated":"2019-07-22T08:49:27.100Z","comments":true,"path":"2019/07/22/关于小程序处理时间格式真机显示NAN的问题/","link":"","permalink":"http://yoursite.com/2019/07/22/关于小程序处理时间格式真机显示NAN的问题/","excerpt":"","text":"开发小程序处理时间格式时遇到在开发者工具中显示正常时间格式，在真机中却显示NAN的问题 一开始发现这个问题感觉非常莫名其妙，而且神奇的是用手机预览时显示NAN，真机调试却能够显示正常，最后发现是因为ios设备不支持new Date(time)的这个time格式为yyyy-mm-dd,必须要转换成yyyy/mm/dd这种格式 所以以下代码处理这个问题： 12345678let date = &apos;2019-01-02 10:58:14&apos;;date.replace(new RegExp(&apos;-&apos;,&apos;g&apos;), &apos;/&apos;);date = date ? new Date(date) : new Date();const year = date.getFullYear();// 月份是从零开始的 所以要+1const mounth = date.getMonth() + 1).toString().padStart(2, &apos;0&apos;);const day = date.getDate().toString().padStart(2, &apos;0&apos;); ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全，padStart(字符串长度，&apos;补全的内容&apos;)","categories":[],"tags":[]},{"title":"小程序组件传值-子传父","slug":"小程序组件传值-子传父","date":"2019-07-18T06:10:33.000Z","updated":"2019-07-18T06:33:50.035Z","comments":true,"path":"2019/07/18/小程序组件传值-子传父/","link":"","permalink":"http://yoursite.com/2019/07/18/小程序组件传值-子传父/","excerpt":"","text":"小程序组件传值-子传父 子组件需要通过事件传值，以点击事件change为例 12345&lt;!-- 子组件B wxml --&gt;&lt;view class=&quot;inner&quot;&gt; &#123;&#123;theIdy&#125;&#125; &lt;button bindtap=&apos;change&apos;&gt;向A中传入参数&lt;/button&gt;&lt;/view&gt; 通过触发“change”事件进行传值操作 12345678910111213141516171819//子组件JSComponent(&#123; //B在这里接收与data类似可以直接在wxml上用 properties: &#123; theId: &#123; type: String,//类型 &#125; &#125;, data: &#123; &#125;, methods: &#123; //触发change事件 change: function () &#123; //通过triggerEvent（给父组件一个事件名称，需要传的参数）传值 this.triggerEvent(&apos;myevent&apos;, this.properties.theId); &#125; &#125;&#125;) 父组件接收 12345&lt;!-- 父组件 wxml --&gt;&lt;view&gt; &lt;temp theId=&quot;&#123;&#123;id&#125;&#125;&quot; bind:myevent=&quot;onMyEvent&quot;&gt;&lt;/temp&gt; &#123;&#123; theId &#125;&#125;&lt;/view&gt; 123456789101112131415// 父组件JSPage(&#123; data: &#123; id: &quot;1&quot;, theId: 0 &#125;, onMyEvent: function (e) &#123; //通过事件接收 this.setData(&#123; theId: e.detail.theId &#125;) &#125;&#125;) 看不懂的可以先看上一篇文章，《关于小程序的组件及传值》","categories":[],"tags":[]},{"title":"关于小程序的组件及传值","slug":"关于小程序的组件及传值","date":"2019-07-18T03:33:23.000Z","updated":"2019-07-18T04:47:14.670Z","comments":true,"path":"2019/07/18/关于小程序的组件及传值/","link":"","permalink":"http://yoursite.com/2019/07/18/关于小程序的组件及传值/","excerpt":"","text":"小程序创建组件及组件传值 父组件JSON配置组件名称 1234567// 父组件JSON（JSON文件中不能写注释，这里只是为了表达清楚）&#123; &quot;navigationBarTitleText&quot;: &quot;父子传值&quot;, &quot;usingComponents&quot;: &#123; &quot;temp&quot;: &quot;../../components/son/son&quot; &#125;&#125; 父组件传值到子组件 12345678910// 父组件 需要传值的数据 Page(&#123; data:&#123; id:&apos;1&apos;, &#125;, onLoad: function(option)&#123; &#125; &#125;) 父组件HTML 1234567&lt;!-- 父组件A wxml --&gt;&lt;!-- 这里的temp标签就是子组件的文件名，也是父组件JSON里配置的组件名称 --&gt;&lt;!-- 这里的theId是子组件接受数据的名字，id则是父组件需要传过去的数据--&gt;&lt;view&gt; &lt;temp theId=&apos;&#123;&#123;id&#125;&#125;&apos;&gt;&lt;/temp&gt;&lt;/view&gt; 子组件JSON配置 12345// 组件需要将component属性设置为true&#123; &quot;component&quot;: true, &quot;usingComponents&quot;: &#123;&#125;&#125; 子组件接收父组件传值 12345678910111213141516//子组件JSComponent(&#123; //在这里接收与data类似可以直接在wxml上用 properties: &#123; theId: &#123; //声明父组件传过来的数据类型 type: String,//类型 //如果需要默认值（初始值）的话可以通过value属性设置 value: &apos;0&apos;//默认值 &#125; &#125;, data: &#123; &#125;&#125;) 子组件使用接收的数据 1234&lt;!-- 子组件 wxml --&gt;&lt;view class=&quot;inner&quot;&gt; &#123;&#123;theId&#125;&#125;&lt;/view&gt;","categories":[],"tags":[]},{"title":"调起小程序导航","slug":"调起小程序导航","date":"2019-07-16T07:33:52.000Z","updated":"2019-07-16T09:44:06.893Z","comments":true,"path":"2019/07/16/调起小程序导航/","link":"","permalink":"http://yoursite.com/2019/07/16/调起小程序导航/","excerpt":"","text":"调起小程序导航ps:首先需要用户授权地理位置。（如果用户拒绝，可以通过弹窗，点击进入getsetting，强制获取授权，否则无法进入小程序） 直接上代码 123456789101112wx.getLocation(&#123;//获取当前经纬度 type: &apos;wgs84&apos;, //返回可以用于wx.openLocation的经纬度，官方提示bug: iOS 6.3.30 type 参数不生效，只会返回 wgs84 类型的坐标信息 success: function (res) &#123; wx.openLocation(&#123;//​使用微信内置地图查看位置。 latitude: 22.5542080000,//要去的纬度-地址 longitude: 113.8878770000,//要去的经度-地址 name: &quot;宝安中心A地铁口&quot;, address:&apos;宝安中心A地铁口&apos; &#125;) &#125; &#125;) 效果图如下","categories":[],"tags":[]},{"title":"实现深拷贝最简单的方法！","slug":"实现深拷贝最简单的方法！","date":"2019-02-23T04:00:54.000Z","updated":"2019-02-23T04:09:40.026Z","comments":true,"path":"2019/02/23/实现深拷贝最简单的方法！/","link":"","permalink":"http://yoursite.com/2019/02/23/实现深拷贝最简单的方法！/","excerpt":"","text":"实现深拷贝最简单的方法 直接上代码 123456789101112131415function deepCopy(obj) &#123; let _obj = JSON.stringify(obj); let objClone = JSON.parse(_obj); return objClone &#125; let arr = [0, 1, 2], arrClone = deepCopy(arr) arrClone[1] = 2 console.log(arr) console.log(arrClone)","categories":[],"tags":[]},{"title":"关于小程序中的text标签问题","slug":"关于小程序中的text标签问题","date":"2019-02-23T03:26:20.000Z","updated":"2019-02-23T03:52:49.625Z","comments":true,"path":"2019/02/23/关于小程序中的text标签问题/","link":"","permalink":"http://yoursite.com/2019/02/23/关于小程序中的text标签问题/","excerpt":"","text":"小程序text标签的各种坑 坑一：回车问题 &ensp;&ensp;在小程序中，text标签会将回车也写入内容，导致空行。所以，如果在我们并不需要空行的情况下，text标签中的内容应当写在一行。 坑二：font-size问题 &ensp;&ensp;如果我们需要使用view标签来包裹text标签，在需要设置font-size属性时，应当给view标签使用，否则可能会出现view标签莫名其妙的变高一点的问题。 坑三：首行缩进问题 &ensp;&ensp;text标签使用首行缩进text-indent属性无效，解决方案：我们可以使用view标签来进行代替。 vertical-align属性使用方法 &ensp;&ensp;vertical-align是垂直居中属性，之前在使用vertical-align属性的过程中，发现竟然不起作用。原因是，使用vertical-align属性的有条件的（就是这么任性）。一个是使用环境：父元素必须设置line-height行高属性；一个是使用vertical-align属性的元素必须是行内块或者行内元素（块级元素不起作用！）。","categories":[],"tags":[]},{"title":"关于小程序页面传值","slug":"关于小程序页面传值","date":"2019-01-21T02:17:34.000Z","updated":"2019-01-21T02:19:48.598Z","comments":true,"path":"2019/01/21/关于小程序页面传值/","link":"","permalink":"http://yoursite.com/2019/01/21/关于小程序页面传值/","excerpt":"","text":"小程序中的三种页面传值方式 url传值 本地储存 全局app对象存储 1、url传值通过url传值，需要通过option来取值 A页面传值 1234wx.navigateTo(&#123; url: &apos;test?id=1&apos;&#125;) B页面取值 123456789101112Page(&#123; data:&#123; id:&apos;&apos;, &#125;, onLoad: function(option)&#123; this.setData(&#123; id:option.id &#125;) &#125;&#125;) 2、本地存储 A页面传值 12wx.setStorageSync(&apos;username&apos;, &apos;张三&apos;) B页面取值 123456789101112Page(&#123; data:&#123; username:&apos;&apos;, &#125;, onLoad: function()&#123; var username = wx.getStorageSync(&apos;username&apos;) this.setData(&#123; username: username &#125;) &#125;&#125;) 3、将数据挂在到全局的app对象 A页面传值 123var app = getApp();app.username=&apos;ddd&apos;; B页面取值 123var app = getApp();var username = app.username;","categories":[],"tags":[]},{"title":"关于小程序setData","slug":"关于小程序setData","date":"2019-01-21T02:16:36.000Z","updated":"2019-01-21T02:19:19.645Z","comments":true,"path":"2019/01/21/关于小程序setData/","link":"","permalink":"http://yoursite.com/2019/01/21/关于小程序setData/","excerpt":"","text":"小程序setData的几种情况示例数据：123456789101112131415161718192021data&#123; isbig:true, dog&#123; age:15, color:red &#125;, arr:[&#123; index:0， name:小红 &#125;, &#123; index:1， name:小白 &#125;, &#123; index:2， name:小黑 &#125;], isArr:[] &#125; 情况一：修改data中的isbig属性，可通过属性名直接修改为fales 1234this.setData(&#123; isbig:fales &#125;) 情况二：修改data中dog属性里的age属性，需要以字符串的方式使用dog中的age属性 1234this.setData(&#123; &apos;dog.age&apos;: 10&#125;) 情况三：属性中的一部分是动态获取的，或者传参传进来的。需要先用变量将属性字符串拼接起来，然后用[]括号括起来即可 12345678910function(e) &#123; let index = e.currentTarget.dataset.index let namechange = &apos;arr[&apos; + index + &apos;].name&apos; this.setData(&#123; [namechange]: &apos;赋值name&apos;, &#125;) &#125; 情况四：当属性是个数组，并需要往数组里添加数据的时候。可先通过this获取属性，将数据修改，然后通过setData将数据进行渲染。 1234567891011function() &#123; var json = &#123; name:&apos;元素一&apos; &#125; this.data.isArr.push(json) this.setData(&#123; isArr: this.data.isArr &#125;)&#125;","categories":[],"tags":[]},{"title":"IE兼容问题","slug":"IE兼容问题","date":"2019-01-16T09:13:55.000Z","updated":"2019-01-16T09:55:10.064Z","comments":true,"path":"2019/01/16/IE兼容问题/","link":"","permalink":"http://yoursite.com/2019/01/16/IE兼容问题/","excerpt":"","text":"IE中a标签跳转不生效&emsp;&emsp;今天才知道，原来a标签里面嵌套input是不符合标准的，所以不能这么做，应该直接把a标签写成按钮的样式，把a标签设置为inline-block就可以了。 &emsp;&emsp;a标签中如果有button, 那么在IE下就不能跳转到herf的链接。而火狐和google中可以如下：此种在IE中不可以。这边的class中的属性只用于按钮样式。 1&lt;a href=&quot;jsp/manage/manage-context.jsp&quot;&gt;&lt;input type=&quot;button&quot; class=&quot;searchbut&quot; value=&quot;返 回&quot;&gt; &lt;/a&gt; &emsp;&emsp;而通过这样在IE中可行。但在火狐和google中则不可以 1&lt;input type=&quot;button&quot; onclick=&quot;window.location.href(&apos;/jsp/manage/manage-context.jsp&apos;)&quot; class=&quot;searchbut&quot; value=&quot;返 回&quot;&gt; &emsp;&emsp;下面这种则在IE,火狐，google中都可以 1&lt;input type=&quot;button&quot; onclick=&quot;window.location.href=&apos;/jsp/manage/manage-context.jsp&apos;&quot; class=&quot;searchbut&quot; value=&quot;返 回&quot;&gt;","categories":[],"tags":[]}]}